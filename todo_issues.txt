Found Issues:
- Update docs -> submodule checkout needs to be performed
- Why not update to go1.18?
Card deps
sudo apt-get install libpcsclite-dev


func ParseTLVPacketV2(data []byte, constructedTags ...byte) (TLVCollection, error) {
	buf := bytes.NewReader(data)
	result := make(TLVCollection)

	// tag with length 0
	// TODO: check correctness
	if len(data) < 2 {
		return result, nil
	}

	

	for {
		tag, err := buf.ReadByte()
		if err == io.EOF {
			return result, nil
		}
		if err != nil {
			return result, err
		}

		var length int
		lenBuf := make([]byte, 2)
		encLen, err := buf.ReadByte()
		if err == io.EOF {
			return result, nil
		}
		if err != nil {
			return result, err
		}

		if encLen == 0x81 {
			var parsedLen uint16
			lenBuf[1], err = buf.ReadByte()
			if err != nil {
				return result, err
			}
			err := binary.Read(bytes.NewReader(lenBuf), binary.BigEndian, &parsedLen)
			if err != nil {
				return result, err
			}
			length = int(parsedLen)

		} else if encLen == 0x82 {
			// bytes 2 and 3 define length
			var parsedLen uint16
			lenBuf[0], err = buf.ReadByte()
			if err != nil {
				return result, err
			}
			lenBuf[1], err = buf.ReadByte()
			if err != nil {
				return result, err
			}
			err := binary.Read(bytes.NewReader(lenBuf), binary.BigEndian, &parsedLen)
			if err != nil {
				return result, err
			}
			length = int(parsedLen)
		} else if encLen < 0x7f {
			// byte 1 defines length
			length = int(encLen)
		} else if encLen == 0x0 {
			return result, errors.New("invalid value length encoding")
		}

		value := make([]byte, int(length))
		_, err = buf.Read(value)
		if err != nil {
			return result, ErrDataNotFound
		}
		result[tag] = append(result[tag], value)
		for _, constructedTag := range constructedTags {
			if tag == constructedTag {
				nestedResult, err := ParseTLVPacketV2(value, constructedTags...)
				if err != nil {
					return result, err
				}
				result = mergeTLVCollections(result, nestedResult)
			}
		}
	}
}


func lala() {
	var length uint16
	a := []byte{0x82}
	aBuf := bytes.NewReader(a)
	b := []byte{0x01, 0x18}
	bBuf := bytes.NewReader(b)

	err := binary.Read(aBuf, binary.BigEndian, &length)
	if err != nil {
		fmt.Println("ERR A", err)
	}

	fmt.Println("AAA", length)

	err = binary.Read(bBuf, binary.BigEndian, &length)
	if err != nil {
		fmt.Println("ERR B", err)
	}

	fmt.Println("BB", length)
}

func parsePrefix(b []byte) (byte, int, int, error) {
	if len(b) == 0 {
		return 0, 0, 0, errors.New("prefix not provided")
	}

	if len(b) < 2 {
		return 0, 0, 0, errors.New("prefix too short")
	}

	tag := b[0]

	if b[1] <= 0x7F {
		return tag, int(b[1]), 2, nil
	}

	if b[1] == 0x81 {
		if len(b) < 3 {
			// TLV too short to encode 2 length bytes (TAG+2 LENGTH bytes)
			return 0, 0, 0, errors.New("invalid TLV - expected 2 bytes length encoding")
		}
		return tag, int(b[2]), 3, nil
	}

	if b[1] == 0x82 {
		if len(b) < 4 {
			// TLV too short to encode 3 length bytes (TAG+3 LENGTH bytes)
			return 0, 0, 0, errors.New("invalid TLV - expected 3 bytes length encoding")
		}
		return tag, int(binary.BigEndian.Uint16(b[2:4])), 4, nil
	}

	return 0, 0, 0, errors.New("invalid value prefix encoding")
}